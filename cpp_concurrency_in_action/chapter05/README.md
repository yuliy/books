# Chapter 5. The C++ memory model and operations on atomic types
Одной из важных фичей C++11 Standard является введение модели памяти (memory model). Для работы с высокоуровневыми примитивами, как, например, mutex, future или condition variable, нет необходимости понимать, за счёт чего они работают. Но для работы с более низкоуровневыми сущностями, понимание модели памяти необходимо.

Одна из целей C++ Standards Commettee - чтобы не было необходимости в более низкоуровневом языке, чем C++. Т.е. программистам должны быть предоставлены все необходимые языковые возможности, чтобы "быть ближе к железу". `atomic` типы данных и `atomic` операции как раз такие возможности и предоставляют. Они предоставляют средства доступа к низко-уровневым операциям синхронизации, которые выполняются за одну-две CPU-инструкции.

В этой главе объясняются базовые идеи модели памяти в C++, а также рассматриваются `atomic` типы и операции. И в конце рассматриваются разные способы синхронизации с использованием операций с `atomic` типами.

Будет сложно :) Но если есть необходимость использовать `atomic` типы/операции или разрабатывать lock-free структуры данных, без этого никак.


## 5.1. Memory model basics
Условно можно выделить два аспекта модели памяти:
  * базовые `structural` (`структурные`) аспекты - относятся к тому, как данные расположены в памяти
  * аспекты `concurrency`

Структурные аспекты важны для `concurrency` (особенно на низком уровне `atomic` типов/операций), поэтому начнём с них. В С++ эта тема крутится вокруг терминов `object` и `memory location`.


### 5.1.1. Objects and memory locations
Все данные в С++ состоят из `objects`. В С++ термин `object` значит не то же самое, к чему мы привыкле в других ООП-языках, как например Java/C#/Python. Ну типа когда `int` - это объект, т.к. наследует `Object` и т.п. В С++ этот термин про другое - про строительные блоки данных.

Стандарт С++ определяет `object` как "a region of storage" (буду далее переводить этот термин как "объект"). `object` имеет свои свойства - такие как тип и время жизни.

Некоторые из этих `objects` - простые типы, такие как `int` или `float`. Но есть также экземпляры user-defined типов. Некоторые объекты (например массивы, экземпляры дочерних классов, экземпляры классов с нестатическими членами-данными) содержат внутри себя `subobjects`.

Независимо от типа объекты хранятся в одной или более `momory locations` (буду далее переводить этот термин как "ячейка памяти). Каждая такая ячейка памяти представляет собой либо объект (или подобъект) скалярного типа (как `unsigned short` или `my_class*`), либо последовательность смежных битовых полей.

В случае битовых полей важно понимать, что хотя смежные битовые поля представляют собой отдельные объект, они всё равно считаются одной ячейкой памяти. На рис 5.1 ниже можно посмотреть как `struct` делится на объекты и ячейки памяти.

Во-первых, вся структура - это объект, состояющий из множества подобъектов. По одному на каждый член-данные (data member). Битовые поля `bf1` и `bf2` разделяют одну ячейку памяти, а поле типа `std::string` состоит из множества ячеек памяти. Стоит обратить внимание, что битовое поле `bf3` нулевой длины занимает свою отдельную ячейку памяти.

> @yuliy: Вообще, я помню, что согласно стандарту возможно выделить область памяти длины 0. Но поскольку любой объект в памяти обязан иметь свой адрес, то в таком случае всё равно сколько-то реальной памяти выделится. Минимум `sizeof(char)`.

![](/img/figure_5_1.png)

Из вышесказанного стоит вынести для себя 4 важные мысли:
  * Всякая переменная - это `object`. Включая те переменные, которые являются членами других объектов.
  * Всякий объект занимает минимум одну ячейку памяти.
  * Переменные `fundamental types` (такие как `int` или `char`) занимают `ровно одну` ячейку памяти, независимо от их размер и даже если они лежат как-то плотно или являются частью массива.
  * Смежные битовые поля являются частью одной ячейки памяти.


### 5.1.2. Objects, memory locations, and concurrency
А вот теперь важное для многопоточки. Всё здесь крутится вокруг `memory locations`. Если два потока обращаются к разным ячейкам памяти - всё ОК. Если они обращаются к одной ячейке памяти, но только для чтения - тоже ОК. Но если хотя бы один поток меняет ячейку, то это race condition.

Чтобы избежать race condition, необходимо каким-то образом задать последовательность доступа к ячейке памяти разными потоками. Один из способов задать порядок доступа - использовать мьютексы. При попытке захватить мьютексы обоими потоками, только одному потоку разрешается захват. Таким образом определяется последовательность доступа. Другой способ - использовать `atomic` операции либо на одной, либо на разных ячейках памяти.

Если порядок доступа двумя потоками к одной ячейке памяти не задан, один или оба потока выполняют не атомарный доступ, а также один или оба потока выполняют запись, то это `data race`. И в С++ это приводит к `undefined behaviour`.

Утверждение выше крайне важное: UB - одна из самых неприятных штук в C++. Согласно стандарту, если хоть где-то в одном месте в коде программы есть UB, работа всей программы - UB :)

В этом утверждении есть ещё важный момент - что UB можно избежать, используя `atomic operation` для доступа к ячейки памяти. Причём это не решает саму проблему гонки! По-прежнему не определено, который поток получит доступ. Однако это возвращает нашу программу в `defined behaviour`.


### 5.1.3. Modification orders
Следующая важная концепция - `modification orders`. Каждый объект в программе на С++ имеет (должен иметь) заданный `modification order`, состояющий из всех операций запись из всех потоков в программе6 начиная с инициализации. В большинстве случаев этот порядок будет отличаться при разных запусках программы. Но в пределах одного запуска этот порядок определён. Если разделяемый объект не `atomic type`, то программисту необходимо позаботиться о синхронизации доступа к объекту самому. Если вдруг разные потоки видят разные последовательности значений одной переменной, значит есть гонка и UB.

Это требование означает, что запрещены определённые виды спекулятивного выполнения, т.к. если поток прочитал некоторое значение в пределах `modification order`, дальнейшие операции чтения этим потоком должны возвращать более поздние версии значений, а последующие операции записи этим потоком должны происходить позже в пределах `modificaton order`. Это также значит, что если была операция записи, а за ней операция стения в том же потоке, то при чтении мы должны увидеть либо значение, записанной в той самой операции записи, либо какое-то из значений следующих за ним в пределах `modification order`.

Хотя потоки должны "договориться" о едином `modification order` (я так понимаю, это значит, что для всех потоков переменная меняется ровно в одном и том же порядке) конкретном объекта, они не обязаны "договариваться" о порядке операций с разными объектами.


## 5.2. Atomic operations and types in C++
`atomic operation` - это неделимая операция. Невозможно из какой-либо потока наблюдать такую операцию завершённой частично. Все потоки всегда видят либо, что операция ещё не выполнена, либо, что она выполнена полностью. Если операция чтения значения атомарна, а также все операции модификации этого объекта тоже атомарны, тогда при чтении мы получим либо исходное значение переменной, либо одно из значений, записанных модифицирующей операцией.

Как оборотная сторона, неатомарная операция может быть "замечена" каким-либо потоком как выполненная частично. Если это операция записи, то значение, наблюдаемое другим потоком может быть ни значением до записи, ни значением после, а чем-то ещё. Часть объекта может быть уже модифицирована, а часть - нет. Это race condition, а значит UB. И описанная ситуация - ещё довольно простая.

В С++ для выполнения `atomic` операций как правило необходимо использовать `atomic` типы.


### 5.2.1. The standard atomic types
